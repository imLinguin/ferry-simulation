"""Log parser module for ferry simulation test validation.

This module provides log parsing and validation functionality for integration tests.
It parses log files generated by the ferry simulation and provides query methods
to validate system behavior.
"""

import re
from dataclasses import dataclass
from datetime import datetime
from typing import List, Optional, Tuple
from collections import defaultdict


@dataclass
class LogEntry:
    """Represents a single log entry from the ferry simulation."""
    timestamp: str  # Format: HH:MM:SS
    role: str       # e.g., "PASSENGER", "FERRY_MANAGER", "PORT_MANAGER"
    identifier: str # e.g., "0000", "0042", or empty for managers
    message: str    # The log message content
    
    @property
    def full_role(self) -> str:
        """Returns the full role identifier including numeric ID if present."""
        if self.identifier:
            return f"{self.role}_{self.identifier}"
        return self.role


class LogParser:
    """Parser for ferry simulation log files with validation capabilities."""
    
    # Log line format: (HH:MM:SS) [ROLE_ID] Message
    LOG_PATTERN = re.compile(r'\((\d{2}:\d{2}:\d{2})\) \[([^\]]+)\] (.+)')
    
    def __init__(self):
        self.events: List[LogEntry] = []
    
    def parse_file(self, filepath: str) -> bool:
        """Parse a log file and populate the events list.
        
        Args:
            filepath: Path to the log file to parse
            
        Returns:
            True if parsing succeeded, False otherwise
        """
        try:
            with open(filepath, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line:
                        continue
                    
                    if not self.parse_line(line):
                        print(f"Warning: Failed to parse line {line_num}: {line}")
                        return False
            return True
        except FileNotFoundError:
            print(f"Error: Log file not found: {filepath}")
            return False
        except Exception as e:
            print(f"Error reading log file: {e}")
            return False
    
    def parse_line(self, line: str) -> bool:
        """Parse a single log line and add it to events.
        
        Args:
            line: Log line to parse
            
        Returns:
            True if parsing succeeded, False otherwise
        """
        match = self.LOG_PATTERN.match(line)
        if not match:
            return False
        
        timestamp = match.group(1)
        role_id = match.group(2)
        message = match.group(3)
        
        # Split role and identifier if present (e.g., "PASSENGER_0042")
        parts = role_id.rsplit('_', 1)
        if len(parts) == 2 and parts[1].isdigit():
            role = parts[0]
            identifier = parts[1]
        else:
            role = role_id
            identifier = ""
        
        self.events.append(LogEntry(
            timestamp=timestamp,
            role=role,
            identifier=identifier,
            message=message
        ))
        return True
    
    def count_by_role(self, role: str) -> int:
        """Count events by role name.
        
        Args:
            role: Role name to count (e.g., "PASSENGER", "FERRY_MANAGER")
            
        Returns:
            Number of events matching the role
        """
        return sum(1 for event in self.events if event.role == role)
    
    def count_matching(self, pattern: str) -> int:
        """Count events with messages matching a pattern.
        
        Args:
            pattern: Substring to search for in messages
            
        Returns:
            Number of matching events
        """
        return sum(1 for event in self.events if pattern in event.message)
    
    def count_ferry_boardings(self) -> int:
        """Count total ferry boarding events."""
        return self.count_matching("Ferry boarded")
    
    def count_ferry_departures(self) -> int:
        """Count total ferry departure events."""
        return self.count_matching("Ferry departed")
    
    def count_security_checks(self) -> int:
        """Count total security check completions."""
        return self.count_matching("Security check completed")
    
    def count_passengers_boarded(self) -> int:
        """Count passengers that boarded ferries."""
        return self.count_matching("Passenger boarded ferry")
    
    def count_passengers_exited(self) -> int:
        """Count passengers that exited ferries."""
        return self.count_matching("Passenger exited ferry")
    
    def verify_chronological(self) -> bool:
        """Verify that all events are in chronological order.
        
        Returns:
            True if events are chronologically ordered, False otherwise
        """
        for i in range(1, len(self.events)):
            prev_time = self._parse_timestamp(self.events[i-1].timestamp)
            curr_time = self._parse_timestamp(self.events[i].timestamp)
            
            if prev_time > curr_time:
                print(f"Chronological order violation: {self.events[i-1].timestamp} > {self.events[i].timestamp}")
                return False
        return True
    
    def verify_security_capacity(self, max_capacity: int = 6) -> bool:
        """Verify that security capacity is never exceeded.
        
        Args:
            max_capacity: Maximum allowed security capacity (default: 6)
            
        Returns:
            True if capacity was never exceeded, False otherwise
        """
        current_capacity = 0
        
        for event in self.events:
            if "Entering security station" in event.message:
                current_capacity += 1
                if current_capacity > max_capacity:
                    print(f"Security capacity exceeded: {current_capacity} > {max_capacity} at {event.timestamp}")
                    return False
            elif "Security check completed" in event.message:
                current_capacity -= 1
                if current_capacity < 0:
                    print(f"Security capacity went negative: {current_capacity}")
                    return False
        
        return True
    
    def verify_ferry_sequence(self) -> bool:
        """Verify that each ferry follows proper state transitions.
        
        Expected sequence: WAITING → BOARDING → DEPARTED → TRAVELING → RETURNED
        
        Returns:
            True if all ferries follow proper sequence, False otherwise
        """
        # State machine for each ferry
        ferry_states = defaultdict(lambda: "NONE")
        
        # Valid transitions
        valid_transitions = {
            "NONE": {"WAITING"},
            "WAITING": {"BOARDING"},
            "BOARDING": {"DEPARTED"},
            "DEPARTED": {"TRAVELING"},
            "TRAVELING": {"RETURNED"},
            "RETURNED": {"WAITING"}  # Ferry can wait for next round
        }
        
        for event in self.events:
            if event.role != "FERRY_MANAGER":
                continue
            
            ferry_id = event.identifier
            current_state = ferry_states[ferry_id]
            new_state = None
            
            # Determine new state from message
            if "Ferry manager waiting" in event.message:
                new_state = "WAITING"
            elif "open for boarding" in event.message:
                new_state = "BOARDING"
            elif "Ferry departing" in event.message:
                new_state = "DEPARTED"
            elif "Ferry traveling" in event.message:
                new_state = "TRAVELING"
            elif "Ferry returning" in event.message:
                new_state = "RETURNED"
            
            if new_state:
                if new_state not in valid_transitions.get(current_state, set()):
                    print(f"Invalid ferry state transition for ferry {ferry_id}: "
                          f"{current_state} → {new_state} at {event.timestamp}")
                    return False
                ferry_states[ferry_id] = new_state
        
        return True
    
    def verify_ramp_capacity(self, max_capacity: int = 5) -> bool:
        """Verify that ramp capacity is never exceeded.
        
        Args:
            max_capacity: Maximum allowed ramp capacity (default: 5)
            
        Returns:
            True if capacity was never exceeded, False otherwise
        """
        current_capacity = 0
        
        for event in self.events:
            if "Passenger entering ramp" in event.message or "Passenger boarded ferry" in event.message:
                if "Passenger entering ramp" in event.message:
                    current_capacity += 1
                    if current_capacity > max_capacity:
                        print(f"Ramp capacity exceeded: {current_capacity} > {max_capacity} at {event.timestamp}")
                        return False
            elif "Passenger boarded ferry" in event.message or "Passenger left ramp" in event.message:
                if "Passenger left ramp" in event.message:
                    current_capacity -= 1
                    if current_capacity < 0:
                        print(f"Ramp capacity went negative: {current_capacity}")
                        return False
        
        return True
    
    def find_first(self, pattern: str) -> Optional[LogEntry]:
        """Find the first event matching a pattern.
        
        Args:
            pattern: Substring to search for in messages
            
        Returns:
            First matching LogEntry or None if not found
        """
        for event in self.events:
            if pattern in event.message:
                return event
        return None
    
    def find_last(self, pattern: str) -> Optional[LogEntry]:
        """Find the last event matching a pattern.
        
        Args:
            pattern: Substring to search for in messages
            
        Returns:
            Last matching LogEntry or None if not found
        """
        for event in reversed(self.events):
            if pattern in event.message:
                return event
        return None
    
    def get_duration_seconds(self) -> float:
        """Calculate the duration of the simulation in seconds.
        
        Returns:
            Duration in seconds, or 0.0 if no events
        """
        if len(self.events) < 2:
            return 0.0
        
        first_time = self._parse_timestamp(self.events[0].timestamp)
        last_time = self._parse_timestamp(self.events[-1].timestamp)
        
        delta = last_time - first_time
        return delta.total_seconds()
    
    def verify_port_lifecycle(self) -> bool:
        """Verify that port opens before closing.
        
        Returns:
            True if port lifecycle is correct, False otherwise
        """
        port_opened = False
        port_closed = False
        
        for event in self.events:
            if event.role == "PORT_MANAGER":
                if "Port opened" in event.message or "Port manager starting" in event.message:
                    if port_opened:
                        print("Port opened multiple times")
                        return False
                    port_opened = True
                elif "Port closed" in event.message or "Port manager shutting down" in event.message:
                    if not port_opened:
                        print("Port closed before opening")
                        return False
                    port_closed = True
        
        return port_opened
    
    def get_passenger_flow(self) -> Tuple[int, int]:
        """Get passenger boarding and exit counts.
        
        Returns:
            Tuple of (boarded_count, exited_count)
        """
        boarded = self.count_passengers_boarded()
        exited = self.count_passengers_exited()
        return (boarded, exited)
    
    def count_vip_passengers(self) -> int:
        """Count VIP passenger related events."""
        return self.count_matching("VIP passenger")
    
    @staticmethod
    def _parse_timestamp(timestamp: str) -> datetime:
        """Parse timestamp string to datetime object.
        
        Args:
            timestamp: Timestamp string in HH:MM:SS format
            
        Returns:
            datetime object (date component is arbitrary)
        """
        return datetime.strptime(timestamp, "%H:%M:%S")
    
    def extract_passenger_attributes(self) -> dict:
        """Extract passenger attributes (gender, VIP status, bag weight) from creation logs.
        
        Returns:
            Dictionary mapping passenger_id to {gender, vip, bag_weight}
        """
        passengers = {}
        pattern = re.compile(r'Passenger created \(gender: (\w+), VIP: (\d+), bag_weight: (\d+)\)')
        
        for event in self.events:
            if event.role == "PASSENGER" and "Passenger created" in event.message:
                match = pattern.search(event.message)
                if match:
                    passenger_id = int(event.identifier)
                    passengers[passenger_id] = {
                        'gender': match.group(1),
                        'vip': int(match.group(2)) == 1,
                        'bag_weight': int(match.group(3))
                    }
        return passengers
    
    def extract_security_events(self) -> List[dict]:
        """Extract security station events with passenger, station, and gender info.
        
        Returns:
            List of dicts with {timestamp, passenger_id, station, gender, event_type}
        """
        security_events = []
        
        # Pattern for assignment: "Passenger X assigned to security station (gender: Y)"
        assign_pattern = re.compile(r'Passenger (\d+) assigned to security station \(gender: (\w+)\)')
        # Pattern for completion: "Passenger X passed the security (station: Y, gender: Z)"
        complete_pattern = re.compile(r'Passenger (\d+) passed the security \(station: (\d+), gender: (\w+)\)')
        
        for event in self.events:
            if event.role == "SECURITY_MANAGER":
                assign_match = assign_pattern.search(event.message)
                if assign_match:
                    security_events.append({
                        'timestamp': event.timestamp,
                        'passenger_id': int(assign_match.group(1)),
                        'station': None,  # Not tracked in assignment log
                        'gender': assign_match.group(2),
                        'event_type': 'assigned'
                    })
                
                complete_match = complete_pattern.search(event.message)
                if complete_match:
                    security_events.append({
                        'timestamp': event.timestamp,
                        'passenger_id': int(complete_match.group(1)),
                        'station': int(complete_match.group(2)),
                        'gender': complete_match.group(3),
                        'event_type': 'completed'
                    })
        
        return security_events
    
    def extract_frustration_events(self) -> List[dict]:
        """Extract frustration increment events when passengers are overtaken.
        
        Returns:
            List of dicts with {timestamp, passenger_id, frustration_level}
        """
        frustration_events = []
        pattern = re.compile(r'FRUSTRATION_INCREMENT - passenger (\d+) overtaken \(frustration: (\d+)\)')
        
        for event in self.events:
            if "FRUSTRATION_INCREMENT" in event.message:
                match = pattern.search(event.message)
                if match:
                    frustration_events.append({
                        'timestamp': event.timestamp,
                        'passenger_id': int(match.group(1)),
                        'frustration_level': int(match.group(2))
                    })
        
        return frustration_events
    
    def extract_baggage_rejections(self) -> List[dict]:
        """Extract baggage rejection events.
        
        Returns:
            List of dicts with {timestamp, passenger_id, bag_weight, ferry_limit}
        """
        rejections = []
        pattern = re.compile(r'BAGGAGE_REJECTED - bag: (\d+) exceeds ferry_limit: (\d+)')
        
        for event in self.events:
            if "BAGGAGE_REJECTED" in event.message:
                match = pattern.search(event.message)
                if match:
                    rejections.append({
                        'timestamp': event.timestamp,
                        'passenger_id': int(event.identifier),
                        'bag_weight': int(match.group(1)),
                        'ferry_limit': int(match.group(2))
                    })
        
        return rejections
    
    def extract_ferry_capacity_events(self) -> List[dict]:
        """Extract ferry capacity tracking events.
        
        Returns:
            List of dicts with {timestamp, ferry_id, current_capacity, max_capacity}
        """
        capacity_events = []
        pattern = re.compile(r'current_capacity: (\d+)/(\d+)')
        
        for event in self.events:
            if event.role == "FERRY_MANAGER" and "current_capacity" in event.message:
                match = pattern.search(event.message)
                if match:
                    capacity_events.append({
                        'timestamp': event.timestamp,
                        'ferry_id': int(event.identifier),
                        'current_capacity': int(match.group(1)),
                        'max_capacity': int(match.group(2))
                    })
        
        return capacity_events
    
    def extract_vip_boardings(self) -> List[dict]:
        """Extract VIP passenger boarding requests.
        
        Returns:
            List of dicts with {timestamp, passenger_id, is_vip}
        """
        vip_events = []
        pattern = re.compile(r'Requesting ramp access \(VIP: (\d+)\)')
        
        for event in self.events:
            if event.role == "PASSENGER" and "Requesting ramp access" in event.message:
                match = pattern.search(event.message)
                if match:
                    vip_events.append({
                        'timestamp': event.timestamp,
                        'passenger_id': int(event.identifier),
                        'is_vip': int(match.group(1)) == 1
                    })
        
        return vip_events
    
    def validate_gender_rules(self) -> Tuple[bool, List[str]]:
        """Validate that security stations follow gender rules (same gender when 2 people).
        
        Returns:
            Tuple of (is_valid, list_of_violations)
        """
        violations = []
        
        # Track active passengers per station with their gender
        station_occupancy = defaultdict(list)  # station_id -> [(passenger_id, gender, entry_time)]
        
        security_events = self.extract_security_events()
        
        for event_data in security_events:
            if event_data['event_type'] == 'completed' and event_data['station'] is not None:
                station = event_data['station']
                passenger_id = event_data['passenger_id']
                gender = event_data['gender']
                
                # Find this passenger in station occupancy and remove
                station_occupancy[station] = [
                    (pid, g, t) for pid, g, t in station_occupancy[station] 
                    if pid != passenger_id
                ]
        
        # For simplicity, we validate based on completion events
        # A more thorough check would track entry/exit explicitly
        # The current logging doesn't give us precise station assignment timing
        
        return (len(violations) == 0, violations)
    
    def validate_ferry_capacity_limit(self, max_capacity: int = 50) -> Tuple[bool, List[str]]:
        """Validate that ferry capacity never exceeds maximum.
        
        Args:
            max_capacity: Maximum allowed ferry capacity (default: 50)
            
        Returns:
            Tuple of (is_valid, list_of_violations)
        """
        violations = []
        capacity_events = self.extract_ferry_capacity_events()
        
        for event in capacity_events:
            if event['current_capacity'] > max_capacity:
                violations.append(
                    f"Ferry {event['ferry_id']} exceeded capacity: "
                    f"{event['current_capacity']}/{max_capacity} at {event['timestamp']}"
                )
        
        return (len(violations) == 0, violations)
    
    def validate_frustration_limit(self, max_frustration: int = 3) -> Tuple[bool, List[str]]:
        """Validate that no passenger exceeds maximum frustration level.
        
        Args:
            max_frustration: Maximum allowed frustration level (default: 3)
            
        Returns:
            Tuple of (is_valid, list_of_violations)
        """
        violations = []
        frustration_events = self.extract_frustration_events()
        
        for event in frustration_events:
            if event['frustration_level'] > max_frustration:
                violations.append(
                    f"Passenger {event['passenger_id']} exceeded frustration limit: "
                    f"{event['frustration_level']} > {max_frustration} at {event['timestamp']}"
                )
        
        return (len(violations) == 0, violations)
    
    def validate_baggage_enforcement(self) -> Tuple[bool, List[str]]:
        """Validate that passengers with overweight bags wait for compatible ferries.
        
        Returns:
            Tuple of (is_valid, list_of_violations)
        """
        violations = []
        passengers = self.extract_passenger_attributes()
        rejections = self.extract_baggage_rejections()
        
        # Track passengers who had baggage rejected but eventually boarded
        rejected_passengers = {r['passenger_id'] for r in rejections}
        
        # Check that rejected passengers eventually find a compatible ferry
        for passenger_id in rejected_passengers:
            boarded = any(
                event.role == "PASSENGER" and 
                int(event.identifier) == passenger_id and 
                "Boarded successfully" in event.message 
                for event in self.events
            )
            
            if not boarded:
                # This could be valid if port closed before they found a ferry
                # Check if port closed
                port_closed = any(
                    event.role == "PASSENGER" and 
                    int(event.identifier) == passenger_id and 
                    "Port is closing" in event.message 
                    for event in self.events
                )
                
                if not port_closed:
                    violations.append(
                        f"Passenger {passenger_id} had baggage rejected but never boarded "
                        f"(and port didn't close)"
                    )
        
        return (len(violations) == 0, violations)
    
    def validate_vip_priority(self) -> Tuple[bool, List[str]]:
        """Validate that VIP passengers have priority (simplified check).
        
        Note: Full validation would require tracking exact queue positions.
        This checks that VIPs exist and board ferries.
        
        Returns:
            Tuple of (is_valid, list_of_violations)
        """
        violations = []
        passengers = self.extract_passenger_attributes()
        vip_boardings = self.extract_vip_boardings()
        
        # Count VIP vs non-VIP passengers
        vip_count = sum(1 for p in passengers.values() if p['vip'])
        vip_boarding_count = sum(1 for v in vip_boardings if v['is_vip'])
        
        if vip_count > 0 and vip_boarding_count == 0:
            violations.append("VIP passengers exist but none attempted boarding")
        
        # This is a basic sanity check; full priority validation requires more complex logic
        return (len(violations) == 0, violations)
